import { NextRequest, NextResponse } from 'next/server'

// Admin authentication
const ADMIN_TOKEN = process.env.ADMIN_TOKEN || 'admin2520'

function isValidAdminToken(token: string): boolean {
  return token === ADMIN_TOKEN
}

// Store active connections
const connections = new Set<ReadableStreamDefaultController>()

// Mock event generator for demonstration
function generateMockEvent() {
  const eventTypes = ['code_generated', 'code_used', 'code_expired', 'user_connected', 'error']
  const type = eventTypes[Math.floor(Math.random() * eventTypes.length)]
  
  const mockCodes = ['ABC123XY', 'DEF456ZW', 'GHI789UV', 'JKL012ST']
  const mockIPs = ['192.168.1.100', '10.0.0.50', '172.16.0.25', '203.0.113.10']
  const mockUsers = ['user_001', 'user_002', 'user_003', 'admin']

  return {
    id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type,
    timestamp: new Date().toISOString(),
    data: {
      code: type.includes('code') ? mockCodes[Math.floor(Math.random() * mockCodes.length)] : undefined,
      user: Math.random() > 0.5 ? mockUsers[Math.floor(Math.random() * mockUsers.length)] : undefined,
      ip: mockIPs[Math.floor(Math.random() * mockIPs.length)],
      details: getEventDetails(type),
      success: type !== 'error'
    }
  }
}

function getEventDetails(type: string): string {
  switch (type) {
    case 'code_generated':
      return 'New access code generated by admin'
    case 'code_used':
      return 'Access code successfully validated'
    case 'code_expired':
      return 'Access code expired naturally'
    case 'user_connected':
      return 'User connected to system'
    case 'error':
      return 'Invalid code validation attempt'
    default:
      return 'System activity'
  }
}

// Broadcast event to all connected clients
function broadcastEvent(event: any) {
  const eventData = `data: ${JSON.stringify(event)}\n\n`
  
  connections.forEach(controller => {
    try {
      controller.enqueue(new TextEncoder().encode(eventData))
    } catch (error) {
      // Remove dead connections
      connections.delete(controller)
    }
  })
}

// Start mock event generation (in a real app, this would be triggered by actual events)
let eventInterval: NodeJS.Timeout | null = null

function startEventGeneration() {
  if (eventInterval) return
  
  eventInterval = setInterval(() => {
    if (connections.size > 0 && Math.random() > 0.7) { // 30% chance every 2 seconds
      const event = generateMockEvent()
      broadcastEvent(event)
    }
  }, 2000)
}

function stopEventGeneration() {
  if (eventInterval) {
    clearInterval(eventInterval)
    eventInterval = null
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const token = searchParams.get('token')

    // Check admin authentication
    if (!token || !isValidAdminToken(token)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Create Server-Sent Events stream
    const stream = new ReadableStream({
      start(controller) {
        // Add connection to active connections
        connections.add(controller)
        
        // Start event generation if this is the first connection
        if (connections.size === 1) {
          startEventGeneration()
        }

        // Send initial connection event
        const initialEvent = {
          id: `connection_${Date.now()}`,
          type: 'connection_established',
          timestamp: new Date().toISOString(),
          data: {
            details: 'Real-time monitoring connected',
            success: true
          }
        }
        
        const eventData = `data: ${JSON.stringify(initialEvent)}\n\n`
        controller.enqueue(new TextEncoder().encode(eventData))

        // Send periodic heartbeat
        const heartbeatInterval = setInterval(() => {
          try {
            const heartbeat = `data: ${JSON.stringify({
              type: 'heartbeat',
              timestamp: new Date().toISOString()
            })}\n\n`
            controller.enqueue(new TextEncoder().encode(heartbeat))
          } catch (error) {
            clearInterval(heartbeatInterval)
            connections.delete(controller)
            
            // Stop event generation if no connections left
            if (connections.size === 0) {
              stopEventGeneration()
            }
          }
        }, 30000) // Every 30 seconds

        // Handle connection close
        request.signal.addEventListener('abort', () => {
          clearInterval(heartbeatInterval)
          connections.delete(controller)
          
          // Stop event generation if no connections left
          if (connections.size === 0) {
            stopEventGeneration()
          }
          
          try {
            controller.close()
          } catch (error) {
            // Connection already closed
          }
        })
      },
      
      cancel() {
        // Connection cancelled by client
        connections.delete(this as any)
        
        // Stop event generation if no connections left
        if (connections.size === 0) {
          stopEventGeneration()
        }
      }
    })

    return new NextResponse(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Cache-Control'
      }
    })

  } catch (error) {
    console.error('Real-time stream error:', error)
    return NextResponse.json({
      error: 'Failed to establish real-time connection'
    }, { status: 500 })
  }
}
